# Day 28

> 2020-10-13

以后一次就写一周的了，然后每次的内容写的好看一点。

## Rust Async Await

阅读了 https://github.com/rustcc/writing-an-os-in-rust/blob/master/12-async-await.md 。

luojia 大佬真是太强了 qaq 。。。

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}

pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
```

其实现原理是，通过编译器生成一个状态机，状态转换主要取决于 if else（常规）和 poll 的结果。

如果状态机遇到了资源不足等问题需要等待，返回 `Poll::Pending` 。下一次 poll 的时候，从上次的状态开始，重试上一个操作。

由于编译器可以知道每个状态继续执行下去需要保存的最少的变量，因此在上下文切换的时候无需每次都保存所有寄存器（如 rcore 中的 switch），而是执行由编译器生成的“保存所需的最少的变量”的代码，速度当然变快了。而且

基于该特征，所有线程可以共用一个调用栈，由编译器负责分配所需内存，而不是每个线程使用一个独立的栈。比如：rcore 中给每个线程分配一个固定大小的栈，而 zcore 在初始化的时候分配一个很大的调用栈给所有线程共用。

具体用法还没读到，明天再看。
